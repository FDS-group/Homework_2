{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "qSfK3TzzOeBK"
   },
   "source": [
    "# Fundamentals of Data Science\n",
    "Winter Semester 2020\n",
    "\n",
    "## Prof. Fabio Galasso, Alessandro Flaborea and Luca Franco\n",
    "<galasso@di.uniroma1.it>, <flaborea.1841969@studenti.uniroma1.it>, <franco.luca.17@gmail.com>\n",
    "\n",
    "## Exercise 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "laIa2DFiOeBL"
   },
   "source": [
    "In Exercise 2, you will re-derive and implement logistic regression and optimize the parameters with Gradient Descent and with the Newton's method. Also, in this exercise you will re-derive and implement Gassian Discriminant Analysis.\n",
    "We will use the files logistic_x.txt and logistic_y.txt. The first contains the feature values $x^{(i)}_1$ and $x^{(i)}_2$ for the $i$-th data sample $x^{(i)}$. The second contains the ground truth label $y^{(i)}$ for each corresponding data sample.\n",
    "\n",
    "Note that, differently from what seen in lecture, $y^{(i)}\\in \\{-1,1\\}$.\n",
    "\n",
    "The completed exercise should be handed in as a single notebook file. Use Markdown to provide equations. Use the code sections to provide your scripts and the corresponding plots.\n",
    "Submit it by sending an email to galasso@di.uniroma1.it, flaborea.1841969@studenti.uniroma1.it and franco.luca.17@gmail.com by Wednesday November 25th, 23:59."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "LK9pUVWmOeBM"
   },
   "source": [
    "## Notation\n",
    "\n",
    "- $x^i$ is the $i^{th}$ feature vector\n",
    "- $y^i$ is the expected outcome for the $i^{th}$ training example\n",
    "- $m$ is the number of training examples\n",
    "- $n$ is the number of features\n",
    "\n",
    "Let's start by setting up our Python environment and importing the required libraries:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "vpM7R9w8OeBN"
   },
   "source": [
    "\n",
    "## [15 points] Question 1: Logistic Regression with Gradient Ascent"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "96Z43pcuOeBN"
   },
   "source": [
    "### (a) [5 points] Equations for the log likelihood, its gradient, and the gradient ascent update rule.\n",
    "\n",
    "Write and simplify the likelihood $L(\\theta)$ and log-likelihood $l(\\theta)$ of the parameters $\\theta$.\n",
    "\n",
    "Recall the probabilistic interpretation of the hypothesis $h_\\theta(x)= P(y=1|x;\\theta)$ and that $h_\\theta(x)=\\frac{1}{1+\\exp(-\\theta^T x)}$.\n",
    "\n",
    "Also derive the gradient $\\frac{\\delta l(\\theta)}{\\delta \\theta_j}$ of $l(\\theta)$ and write the gradient update equation. \n",
    "\n",
    "Question: in order to learn the optimal $\\theta$, do you need to minimize or to maximize $l(\\theta)$?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ryllEcxDOeBO"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "wgkYGHGSOeBO"
   },
   "source": [
    "Your equations and answers here."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "yEco3MQ1OeBP"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "4nCv4HmWOeBP"
   },
   "source": [
    "### (b) [10 points] Implementation of logistic regression with Gradient Ascent\n",
    "\n",
    "Code up the equations above to learn the logistic regression parameters. Consider as data the files logistic_x.txt and logistic_y.txt. The first contains the feature values $x^{(i)}_1$ and $x^{(i)}_2$ for the $i$-th data sample $x^{(i)}$. The second contains the ground truth label $y^{(i)}$ for each corresponding data sample."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "id": "n9qXilF-OeBQ"
   },
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import numpy as np # imports a fast numerical programming library\n",
    "import scipy as sp # imports stats functions, amongst other things\n",
    "import matplotlib as mpl # this actually imports matplotlib\n",
    "import matplotlib.cm as cm # allows us easy access to colormaps\n",
    "import matplotlib.pyplot as plt # sets up plotting under plt\n",
    "import pandas as pd # lets us handle data as dataframes\n",
    "\n",
    "# sets up pandas table display\n",
    "pd.set_option('display.width', 500)\n",
    "pd.set_option('display.max_columns', 100)\n",
    "pd.set_option('display.notebook_repr_html', True)\n",
    "\n",
    "import seaborn as sns # sets up styles and gives us more plotting options"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "bBZrP2jQOeBU"
   },
   "source": [
    "Let's start by loading the data into two pandas DataFrames:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 203
    },
    "id": "AIYevbmGOeBU",
    "outputId": "754a01ff-66bb-487d-99ac-bd7be41f4183"
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>x1</th>\n",
       "      <th>x2</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1.343250</td>\n",
       "      <td>-1.331148</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1.820553</td>\n",
       "      <td>-0.634668</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0.986321</td>\n",
       "      <td>-1.888576</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>1.944373</td>\n",
       "      <td>-1.635452</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>0.976734</td>\n",
       "      <td>-1.353315</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "         x1        x2\n",
       "0  1.343250 -1.331148\n",
       "1  1.820553 -0.634668\n",
       "2  0.986321 -1.888576\n",
       "3  1.944373 -1.635452\n",
       "4  0.976734 -1.353315"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_x = pd.read_csv(\"./data/logistic_x.txt\", sep=\"\\ +\", names=[\"x1\",\"x2\"], header=None, engine='python')\n",
    "df_y = pd.read_csv('./data/logistic_y.txt', sep='\\ +', names=[\"y\"], header=None, engine='python')\n",
    "df_y = df_y.astype(int)\n",
    "df_x.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 203
    },
    "id": "yzWVpxZKOeBY",
    "outputId": "087f03ed-90c2-43ba-ecc0-4e1eede2698e"
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>y</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   y\n",
       "0 -1\n",
       "1 -1\n",
       "2 -1\n",
       "3 -1\n",
       "4 -1"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_y.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "dvJngk29OeBb"
   },
   "source": [
    "Let's get the NumPy arrays from the dataset, and add a column of 1's to $X$ to take into account the zero intercept"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "id": "s2Jz97G4OeBb"
   },
   "outputs": [],
   "source": [
    "x = np.hstack([np.ones((df_x.shape[0], 1)), df_x[[\"x1\",\"x2\"]].values])\n",
    "y = df_y[\"y\"].values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "JyWYlB43OeBe"
   },
   "source": [
    "Adjust y so that $y^{(i)}\\in [0,1]$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "S5njaB8wOeBe"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "kl6TZcBYOeBf"
   },
   "source": [
    "Your code here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "id": "HzS95OcYOeBf"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n",
       "       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n",
       "       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n",
       "       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y=np.interp(y, (y.min(), y.max()), (0, +1))\n",
    "y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "eh_JgsQoOeBi"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 185
    },
    "id": "_S8E0b9_OeBj",
    "outputId": "8c33615a-da97-48e0-8ca4-2f64b60b1093"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[array([[ 1.        ,  1.3432504 , -1.3311479 ],\n",
       "        [ 1.        ,  1.8205529 , -0.6346681 ],\n",
       "        [ 1.        ,  0.98632067, -1.8885762 ],\n",
       "        [ 1.        ,  1.9443734 , -1.635452  ],\n",
       "        [ 1.        ,  0.97673352, -1.3533151 ]]),\n",
       " array([[ 1.        ,  4.7748538 ,  0.09941521],\n",
       "        [ 1.        ,  5.8274854 , -0.69005848],\n",
       "        [ 1.        ,  2.2894737 ,  1.9707602 ],\n",
       "        [ 1.        ,  2.494152  ,  1.4152047 ],\n",
       "        [ 1.        ,  2.0847953 ,  1.3567251 ]])]"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "[x[:5,:],x[-5:,:]] # Plot the first and last 5 lines of x, now containing features x0 (constant=1), x1 and x2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "id": "DZFFdmUqOeBm",
    "outputId": "e68613e6-4b26-4d1b-e22e-3f9b82e8b3cc"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[array([0., 0., 0., 0., 0.]), array([1., 1., 1., 1., 1.])]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "[y[:5],y[-5:]] # Plot the first and last 5 lines of y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "qe5LdnkmOeBo"
   },
   "source": [
    "Define the sigmoid function \"sigmoid\", the function to compute the gradient of the log likelihood  \"grad_l\" and the gradient ascent algorithm."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "iK3e_-LmOeBp"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "F9D5RR6XOeBp"
   },
   "source": [
    "Your code here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "id": "seSHjGU7OeBq"
   },
   "outputs": [],
   "source": [
    "def sigmoid(x):\n",
    "    g=1/(1+np.exp(-x))\n",
    "    return g # return the sigmoid of x\n",
    "    # return g\n",
    "#print(sigmoid(x).shape,\"sigmoid x\",sigmoid(x[:,1]).shape,\"sigmoid x1\",end=\"\")\n",
    "    \n",
    "def log_likelihood(theta,x,y):\n",
    "    theta_x=np.dot(x,theta_test)\n",
    "    log_l=theta_x*(y-1)-np.log(1+np.exp(-theta_x))\n",
    "    log_l=sum(log_l)/99\n",
    "    #print(theta.shape,\"theta\",y.shape,\"y\",t.shape,\"t\",end=\"\")\n",
    "    #print(a.shape,\"a\",b.shape,\"b\",c.shape,\"c\",log_l.shape,\"log l\")\n",
    "    #log_l=(-t)*x-np.log(1+np.exp(-t*x))+y*(t*x)\n",
    "    return log_l # return the log likehood of theta according to data x and label y\n",
    "    # return log_l\n",
    "    \n",
    "#print(log_likelihood(theta_test,x,y))\n",
    "\n",
    "\n",
    "def grad_l(theta, x, y):\n",
    "    grad1=np.dot(y,x)\n",
    "    theta=theta[np.newaxis].T\n",
    "    t=np.dot(x,theta)\n",
    "    g=sigmoid(t).T\n",
    "    grad2=np.dot(g,x)\n",
    "    G=grad1-grad2\n",
    "    return G[0] # return the gradient G of the log likelihood\n",
    "    # return G\n",
    "\n",
    "\n",
    "def gradient_ascent(theta,x,y,G,alpha=0.01,iterations=100):\n",
    "\n",
    "    m = len(y)\n",
    "    log_l_history = np.zeros(iterations)\n",
    "    theta_history = np.zeros((iterations,3))\n",
    "    G=G(theta,x,y)\n",
    "    prod=alpha*G\n",
    "    opttheta=theta+prod.T\n",
    "    \n",
    "    for i in range(iterations):\n",
    "        log_l=log_likelihood(opttheta,x,y)\n",
    "        log_l_history[i]=log_l\n",
    "        theta_history[i]=opttheta\n",
    "        G=grad_l(opttheta,x,y)\n",
    "        prod=alpha*G\n",
    "        opttheta+=(prod.T)\n",
    "        \n",
    "\n",
    "    return opttheta,log_l_history,theta_history # return the optimized theta parameters,\n",
    "        # as well as two lists containing the log likelihood's and values of theta at all iterations\n",
    "    # return theta, log_l_history, theta_history"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ne6TYR_GOeBu"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check your grad_l implementation:\n",
    "grad_l applied to the theta_test (defined below) should provide a value for log_l_test close to the target_value (defined below); in other words the error_test should be 0, up to machine error precision."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.000000\n"
     ]
    }
   ],
   "source": [
    "target_value = -0.4250958770469834\n",
    "theta_test=np.array([-2,1,2])\n",
    "\n",
    "log_l_test  = log_likelihood(theta_test,x,y)\n",
    "error_test=np.abs(log_l_test-target_value)\n",
    "\n",
    "print(\"{:f}\".format(error_test))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "vjpqRLekOeBv"
   },
   "source": [
    "Let's now apply the function gradient_ascent and print the final theta as well as theta_history "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 151
    },
    "id": "E9YW5A-aOeBv",
    "outputId": "2c0e0da0-f9e9-4bb7-bbc2-6d5978ac9059"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-58.95104265  50.45715696  67.10277129]\n",
      "[[ -0.25        23.83452377  27.46411597]\n",
      " [-17.62210474 -34.99184238  45.56598762]\n",
      " [  5.43334214  83.44009046  60.61944202]\n",
      " ...\n",
      " [-57.9470277   16.6073454   12.19926929]\n",
      " [-58.87688718   2.65648345  13.60582983]\n",
      " [-34.44758976 123.29286753  32.18129331]]\n"
     ]
    }
   ],
   "source": [
    "# Initialize theta0\n",
    "theta0 = np.zeros(x.shape[1])\n",
    "\n",
    "# Run Gradient Ascent method\n",
    "n_iter=1000\n",
    "theta_final, log_l_history, theta_history = gradient_ascent(theta0,x,y,grad_l,alpha=0.5,iterations=n_iter)\n",
    "print(theta_final)\n",
    "print(theta_history)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "aFv3R0V4OeBy"
   },
   "source": [
    "Let's plot the log likelihood over iterations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 279
    },
    "id": "8e4XivQrOeBy",
    "outputId": "c3b202b0-bd07-4690-d310-673f04959bb4"
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig,ax = plt.subplots(num=2)\n",
    "\n",
    "ax.set_ylabel('l(Theta)')\n",
    "ax.set_xlabel('Iterations')\n",
    "_=ax.plot(range(len(log_l_history)),log_l_history,'b.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "g0sfyGRyOeB1"
   },
   "source": [
    "Plot the data and the decision boundary:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 195
    },
    "id": "KQClMhK9OeB2",
    "outputId": "73ca95f2-de91-419b-9188-f98fb9b5386f"
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>y</th>\n",
       "      <th>x1</th>\n",
       "      <th>x2</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>-1</td>\n",
       "      <td>1.343250</td>\n",
       "      <td>-1.331148</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>-1</td>\n",
       "      <td>1.820553</td>\n",
       "      <td>-0.634668</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>-1</td>\n",
       "      <td>0.986321</td>\n",
       "      <td>-1.888576</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>-1</td>\n",
       "      <td>1.944373</td>\n",
       "      <td>-1.635452</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>-1</td>\n",
       "      <td>0.976734</td>\n",
       "      <td>-1.353315</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   y        x1        x2\n",
       "0 -1  1.343250 -1.331148\n",
       "1 -1  1.820553 -0.634668\n",
       "2 -1  0.986321 -1.888576\n",
       "3 -1  1.944373 -1.635452\n",
       "4 -1  0.976734 -1.353315"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_x_pl=df_x.copy()\n",
    "df_y_pl=df_y.copy()\n",
    "df_x_pl.insert(0, \"y\", df_y)\n",
    "df_x_pl[\"y\"] = pd.to_numeric(df_x_pl[\"y\"], downcast='signed')\n",
    "df_x_pl.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 279
    },
    "id": "o7UgpsNFOeB4",
    "outputId": "0c716ca2-ca3c-42fc-b731-c9e3992b27c1"
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYEAAAEGCAYAAACD7ClEAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOydd3hUZfbHP/dOn0lvJCH0XsSGHXtBwYYFQbGisnZXV/2pq+7aV9fuWrEvKyr2sij27go2UHpN7336ve/vjwsJwwRImZbM+3mePJo3M3MPmck973nPOd+jCCGQSCQSSXKixtsAiUQikcQP6QQkEokkiZFOQCKRSJIY6QQkEokkiZFOQCKRSJIYc7wN6Ao5OTli8ODB8TZDIpFIehVLliypEULkdvSzXuUEBg8ezOLFi+NthkQikfQqFEXZuL2fyeMgiUQiSWLi7gQURTEpivKzoijvxdsWiUQiSTbi7gSAK4Dl8TZCIpFIkpG45gQURSkCpgJ3AFd15zUCgQAlJSV4vd6I2hZr7HY7RUVFWCyWeJsikUiSiHgnhh8ErgVSt/cARVEuBC4EGDhwYNjPS0pKSE1NZfDgwSiKEi07o4oQgtraWkpKShgyZEi8zZFIJElE3I6DFEU5FqgSQizZ0eOEEE8JISYKISbm5oZXOHm9XrKzs3ulAxBCEAgEcbd6cDlTcLvd8TZJIpEkGfGMBA4AjlcUZQpgB9IURfm3EGJWV1+oNzoAgIA/wLo1G9E0DYCGpkbqahvIys6Is2USiSRZiFskIIS4XghRJIQYDMwAPu2OA+itaJpOZUVNmwMA8Hp8lJdWxNEqiUSSbCRCdVBSIoROIBAIW6+sqI6DNRKJJFlJCCcghPhcCHFsvO2IJSaTiczM9JA1RVEYt8voOFkkkUiSkYRwAr2Zm266iYceeqjt+xtvvJGHH354p89TFIXU9BTyC/ths9twpbjIycuS+QCJRBJTpBPoIbNnz+aFF14AQNd15s+fzxlnnNGp55rNZrKyMxg8ZAADBhZisViwWGWfgEQiiR3x7hPo9QwePJjs7Gx+/vlnKisr2X333cnOzu708xVFwWyRb4NEIokP8u4TAc4//3yef/55KioqOO+88+JtjkQikXQaeRwUAaZNm8bChQv58ccfmTx5crzNkUgkkk4jI4EIYLVaOfTQQ8nIyMBkMsXbHIlEIuk00glEAF3X+f7773nttdfibYpEIpF0CXkc1EP++OMPhg8fzuGHH86IESPibY5EIpF0CRkJ9JCxY8eybt26eJshkUgk3UJGAhKJRJLESCcgkUgkSYx0AhKJRJLEyJyARCLpEl6Pj9qaOr767HsKCvsxfrcxZOdkxtssSTeRkUCUee211xg3bhyqqrJ48eJ4myOR9Ji1qzdw3KGzuPOmB7ls9vVccs511NXUx9ssSTeRTiDKjB8/njfeeIODDjoo3qZIJD2mqbGFB+9+gmAg2Lb2x9KVlBSXx9EqSU9IuuMgX30tnopS9IAf1WLFkd8fW2bnBd+6ypgxY6L22hJJrNE0DXerJ2zd4w5fk/QOkioS8NXX0lqyET3gB0AP+Gkt2YivvjbOlkkkvYPMrHTOmTMjZC07N4thIwbHxyBJj0mqSMBTUQpCD10UOp6K0h5FA0cccQQVFeGzge+44w5OOOGEbr+uRJKI7HPAnjzx0j+Z/+KbFBblc86FM8jOzYq3WZJuklROYEsE0Nn1zvLxxx/36PkSg/q6Bqoqa6iqqGHkmGFkZWXIITsJSFp6KvsftBe7TxyP2WLGYuncexQMBGloaMJkUsnMkhP0EoWkcgKqxdrhDV+1WONgjWRrGuobufPmh/jw3U8BsNttvPTWY4waMzzOliUOdbUNVFfV0NLUysAhRWTnZKKq8TvRdTgdnX5sfV0jr7/8Lgv+8y5Z2Rlc97fLGTV2OHa7LYoWSjpDUuUEHPn9Qdnmn6yoxnqUePPNNykqKuK7775j6tSpct7AdqirbWhzAABer49//O0RGhua42hV4lBX28D1V9zGqUfP5tzpl3PK5HMpL62Mt1mdQtd1Pnr/Mx6+52nKSipY9usKzp1+OQ11DfE2TUKSOQFbZjauokFtO3/VYsVVNCiq1UHTpk2jpKQEn89HZWUlH374YdSu1ZtpbGgKW6upqiUYCMTBmsRj47pivvuqvc+kvq6RJx9+Ea/HG0erOkdTQzPvvvFRyFowEGTpL8vjZJFka5LqOAgMRxDNm76kexQNLCQ9Iy3EGUybMZX0zLQ4WpU4lJeF7/pLNpXh9wewO+xxsKjz2Bw2Bg8t4reffg9Z7z+gIE4WSbYmqSIBSeKSlZ3BvLce5/CjD2L0uBFcd8tlTJs+BbM5sfcpQgjcbg+apkX1OrvvtUtYkvyU048jLT01qteNBA6HnYv/fB65ee2br8nHHUZB/35xtEqyhcT+C5MkDSaTiYFDirj9vuvx+fykZ6Qm/KjOutoGPv3wKz5f9A177bc7x510FFlR0tDJys7kpTce45+3/4vG+iZmnnMS+x+0d1SuFQ0K+vfjlffnUl1Vg8vlJC0jlYzM9HibJUE6AUmC4Upx4kpxxtuMndLa4uaRe57m9fnvAfDlp9/x/TdLuOuhv5KREfkjLJvNythdRvLgU7cTCATJyExLeCe5NYqikJOXRU6e7CdINKQTkEi6QWurm7cX/Ddk7ZvPf8Dr9kIUnMAWesPxT7Txen0gRMLnQnoL0glIJN1AUcBqsxIMtmvmmEwmFFWJo1V9G6/XR2lxOXMf/TfBYJDzL5nFwMFFOJzSGfQEmRiOEAsXLmTUqFEMHz6cu+++O97mSKJMWnoqF//5vJC1M849uVccZfVWqitqOPWY2bz/1iI+fO8zZhx7YYdVU5KuISOBCKBpGpdccgmLFi2iqKiIvfbai+OPP56xY8fG2zRJlLDZbJxw6tHsvf/u/PDtT+y253gGDS4iJcUVb9P6LG8vWBgiYa1pGi+/8AY33HoliiIjsO6SdE5g4w8rWPr2N7jrmnFmpbLLCQcwaJ/RPXrN//3vfwwfPpyhQ4cCMGPGDN5++23pBBIUXdepq6nH4/Fit9tIy0jDZuu6dEh6RhrpGWmMHjciClZKtiU9IzwfkpGRJh1AD0mq46CNP6xg8byPcdcZUgTuumYWz/uYjT+s6NHrlpaWMmDAgLbvi4qKKC0t7dFrSqLH+jWbmHHshUw96HSOO3QW3331Iz6vL95mSXbC5OMOC6kuyshM55TTj4uLLUIIaqrrKN5YSlVFTa/o3N4eSRUJLH37GzR/MGRN8wdZ+vY3PYoGhBBha3J3kpjU1TZw/ZW3U1VZA4C71cN1l97Ku1/MI0+KmSU0uXnZvPL+XH787mc0TWefA/YgJ04S1sUbSrlw1tWUlVRgt9u4+a6/cNjRB+LsgqheopBUTmBLBNDZ9c5SVFREcXFx2/clJSUUFhb26DUl0UHXNFb+sSZkzePx4nH33p1csqAoCrl52Uw54Yi42tHY0MQt191DWYkxQ8Tr9XHztf9gr/1375VOIKmOg5xZHddYb2+9s+y1116sXr2a9evX4/f7mT9/Pscff3yPXlMSHSxWCxP33S1kLSMzHaer9/3xSuKD3x8I20gEA0GaeqnibVI5gV1OOACTNTT4MVnN7HLCAT16XbPZzKOPPsrkyZMZM2YM06dPZ9y4cT16TUl0SM9I4/b7r2ePvSYAMHjoAJ789z/lkBNJp3E47OxzwJ4ha06Xo9fKYMTtOEhRlAHAi0A+oANPCSEeiuY1t5z7R7o6CGDKlClMmTKlx68TT4LBYMILtkWCgsJ+PPj07fj9AUwmlewcKWUg6TwpqS6uv/UKPG4P3321mKKBhdzxwA29VvE2nn/xQeBqIcRPiqKkAksURVkkhPgjmhcdtM/oiNz0+xJ1tQ1899WPfPXZ9xx8+P7sO2nPPr8zTuRdm67r1NU2EPAHsFgtZOdkykKDBCOvXw73PHoLPq8PVVXJ6sXvUdycgBCiHCjf/P/NiqIsB/oDUXUCklCam1q4747HePd1Y9jNB299zCmnH8dVN14kG5/igK7rrF65nisvuIHS4gr6Dyjgobl3MGLU0F57k+mrpKWnQh/QckqInICiKIOB3YEfOvjZhYqiLFYUZXF1dXWsTevzuFs9vP/mopC1N1/5AHeLO04WJTd1tQ1ccb7hAABKi8u54vwbqa2pj7Nlkr5K3J2AoigpwOvAlUKIsBmDQoinhBAThRATc3NzY29gH0dRQN1G9Ew1qYDcdcYDv8/fVnq4hdLicvx+f5wskvR14uoEFEWxYDiAeUKIN+JpS7LiSnEx/cwTQ9ZmnXcKKanyKCgeWG2WsIlb/QfkY7V2XdZCIukM8awOUoBngOVCiPvjZUey40pxMufyszjkiP35/usl7H/QXowcPUzWzceJrOxMHpp7B1ecfyPlpZUUFuXz4NN3kh2liWUSSTyrgw4AzgSWKoryy+a1G4QQH8TRpm5x3nnn8d5775GXl8eyZcvibU6XyczKYN9JE9l30sR4m5L0qKrKyNHDmPf2E/h9fqw2K1nZGTIpLIkacTsOEkJ8LYRQhBAThBC7bf7qdQ4A4JxzzmHhwoXxNkPSR1BVlZzcLAqL8snJzUJV4566k/Rhku7T9f5bi5i8/3R2HXwIk/efzvtvLdr5k3bCQQcdRFaWbDiSxJ6aqlq++vR7vv78B2qq6+JtjiTCuFvdVJRV8r9vf6KspIKW5taIX6Pvt4duxftvLeLv/3cvXo8hG1xeWsnf/+9eAKaeeGQ8TZNIukxVRQ2nHz+nTRG1/4B8XnzjMXLzsuNsmSQSBAIBvv3yR/5y8d/QdR1FUbjlH9cw5fgjsDsip3ibVJHAw/c83eYAtuD1+Hj4nqfjZJFka4QQBAKBeJvRa3h7wX/bHABAaXEFnyz8Mo4WSSJJQ30Tt15/H7quA8bfxz9ueZimpsgK1SVVJFBRVtWldUnsqK2p58P3PuWXxcs45vjD2X2vXRJa2iHeCCGoLA//3Ha0JukcmqZRW1PPsl+Xk56RxpChA8mKY1WWrus01DeGrHk8XoJBLaLXSSonkF+YR3lp+GDq/MK8OFjTuwgEAjTUNyF0HbvDbrTMR4j6ugb+cvEtLPnhVwAWvvspF/35XM67aCY2W+8e9KIHAiAEKAqK2RyxKh9FUZg+60Rem/du21AjVVU5/pRjIvL6yUhZSQWnTb2g7dx93ITRPPrc3XErz7XbbOw7aSLff724bW3sLqOwR3j4UVIdB11+7QVhZ2l2h43Lr72gR687c+ZM9ttvP1auXElRURHPPPNMj14vGrQ0t+L3da/rtLWllU8WfsVJR57Dkfueyo1X3UltBJOQ7lZPmwPYwktzX6W5KfJJsFii+bw0r19Fw4rfaFq7As3r6XAKXXfpP6CA5xc8wn4HTmTSIfvw77ceI79AdtV3B6/Hy+MPPh+SeP39txWsXrEubjalZ6ZxxwM3cPLMYxkwqD/HnnQUD829g6zsyIo7JlUksCX5+/A9T1NRVkV+YR6XX3tBj5PCL7/8ciTMiwqNDU0s/v4XXpv3DgMGFnLeJWeQX5DXpR1pY0Mz1112a9sN7IuPv+W5J+dz2TWzI7JT78gWi8Vs7KAjiKZp+P0BHA57RF+3I/RggJaNa9G8HuN7v4/m9atJHzEWxWKJyDVcKU52n7gL9z1+K4Ds8u4BgUCQmqrwjU1tTXwrrnLzsrnulstoaXHjdDqi0sSZVE4ADEeQLJVAuq7z6Udfc8s1/2hb+/jDr3jtg7nkdKGCZPXKdWE72O++/DFixzUul5Ojph7CR+9/3rZ2ydWzI5oTqKmu4/WX3+OPpSuZOu1I9t5v9+jmHIRocwBtS8EAYnOSL5LE8+bvcXupqqjmndc/JC8/h8MnH9ilz1aikJqWwhnnnhxy9OJw2Jm4z247eFZssDvs2KO4cUk6J5BMNNQ38u9nXgtZq62uY9PG0i79oQ4ZNjBsbdc9x0Vsnmp6Zho33HYlJ5xyNL/+/AeHHjmJooGFmC2R+XjW1dZz0VnXtI0E/Oyjr7nsmvM5Z84MLBHalYejoNrs6L722cWKyYSyjVhfQ30jwUAQs8XcKxPh69ZsZNaJF6FpRrLy+Sfn89Kbj8VtAHxP2H2vXXjw6Tt4ae6rZGSmc9lfzicrJ4OmxmZKi8v5bNE3jJ8wivG7jY34kUw86RNOQAjR7YSbpmlomobH7cVms2K2mOMyXSuSZ8VbUE0m0tJSwtZdLmeXXiczK4PrbrmMB+9+Ep/Pz/hdR/OnK8+J6O4kKzuTAw/bjwMP2y9ir7mFlubWsJmw/37mNU6cPiVqNfWqxULKwKG0bFiNHgigmMykDBqGYmr/bJVsKuOmq+/ilyW/M2H3sdx+/w0MGFQYFXu20NjQRHVlLWtWrWf8rqPJzErH1c25ES0trfzr/mfaHAAYiqcrfl/NpEP2iZTJMSMtPZXDjprEnntPwGw240pxEgxqfPrhV9y8VTR92OQD+ds/rumVTrsjer0TsNvt1NbWkp2d3WVHIITA3eph04ZSwLgJZ+VkktcvB5PJFAVrt29HbW0tdntkQ76MjDSuuvFizj7lUoKBIAAT992N3H45XXqd1LQUTpp5LEdOOZhgUMPusPeqnVBH76XD6SAYCFJRVtU2vSvi17U7SBs+BqELFFVBMZlRNktA1NbUc8UFN7YlHn9evJTLZ1/P3PkPRq0apaW5leefms8z/5oHGLmY+x6/lUOPOqB7n3cBuhZ+vLW1U+iNpGe0j4lsqGvkkXvnhvz80w+/4tqbL5VOIFEoKiqipKSE7gyc0TSdmupatK3qbisqy6mty42pEwDDmRUVFUX8dUeMGsp7n8/jh2+WUFhUwIhRQ7p1A3c47DFJqEYDV4qTw44+kE8XftW2dvm1F/DoP+fy7hsfMWzEYB6aewcDB0f2968oCoqlYwlov88fVnmydvWGbldwdYbWFjfPPd5exCCE4M6bH2C3iePIye16RJSS6mLO5Wfz3VeL2yLZ3Lxsxu0yKmI2xx+Br4P3RI9Cbide9HonYLFYGDJkSLeeW1Ndx+xTrsLj8Yasv/fFfxg4uH8kzIs7doeNwqJ8pp02Nd6mxI2MzHRuvvMvzDhzGst/X82kg/fm84+/4d03PgKMm+91l93GYy/8I2azlc0WM9m5WSGltlnZGSF5kNrqOlpbPVitFpwuR497MwKBQNjNq6G+qUdFWCPHDOPVD+byyotv0a8gl2mnTSW7F+YDtkdaRhpnX3haSDQwYY9xXT5STWR6vRPoCa4UJyeeNoWXn2+fZzN0xCBcUku/z5GVncG+k/Zk30l7UrKpPCzE//23FW1HZrEgMyuDex69hcvO+z/crR4cTgf/eORmMjcfMVRV1HDBGVexfs1GFEVhxlknctGfz+3REYTT6WDU2OEh+ZHjTjqqR593V4qTUWOH89c7r+qTaqdWq4VTzzieEaOG8v5bi5iw+1imnHgEmb3oOHRnKNFISEaLiRMnisWLF+/8gV2grraBdxYs5OP/fsGY8SO54NJZ5OXLhpu+THVlDScecTbNTS1ta2PGj+DxF/8Z01yH3x+gsb6R1lYPLpeDtIw0bDYrPq+f++58jPkvvBny+Nf++wyjxg7v0TWrKmt45l/zWPbrcg45chInzzy2V+V34onfH8BiiVzXdyxRFGWJEKLDgSFJ7wTASGQ1N7Zgd9oj3pItSTwCgQC//fwHf7n4b9RW1zFoSBGPPHs3g4cOiLdpgHFEc9ns/+PXJb+HrP/j4Zs45oQjevz6Pq8fj9tDSpoLk6oidA1FNbUlrSV9jx05gaQ+DtqCyWQiI6tvZPolO8disbDrHuN59YO5BPwBbHYrWdk9q8gJBjVUVYnIkUhqmosjjzkkxAmoqsqEPcb1+LUBbHYrNrsVPeDHXV5G0N2CxZWGPbcfatT6JiSJinQCkqTEbDZFpEfA4/ZSVlrBvGcXkJLqYsbZ0+iXv/PqstYWN263B0VRyMhMx2xuf7zJZOK4k4+ivKySN+a/T1Z2OtffeiWZEdyo6MEgLRvXEXQbR2Kax43m8+AaMAQ1Dn0ykvghj4Mkkh6weuU6ph9zflttfGpaCm8sep5+O8gr1dXWc/+dT/DBW4tIy0jj+luv4ICD9g6Tf/B6vLQ0t6IoCpnZGRFNvGp+H40rloatZ4yZgLqdslZJ72VHx0HyELCT6FqQoNeDt6aSQGszelAOP0l2/H4/zz3xckhzVHNTC19+8t12nxMMBlnw8nu8s2AhwaBGXU09117y9zDdeDA0Y3LyssmOwpxhRVFgmwSnosa2N0aSGEgn0AmErhNoaqBp1e+4y4ppXrsSd3kpejB2JYWSxENRFKy28F2zZQeaRy1NrXyx6JuQNSEEv/+2MuL27RDVhCM/tDnOWTggRNZCkhxIJ9AJhBbEXVYSsuavr4mKIqSk92CxWDh3zgxsWzmCnLwsDjh4+7o5TpeD8buNCVsfNmJwNEzcLqrJhC0rm/RR43ENGkb6qPFY0jNkhVASIt1+J+n4ht978imS6FDQP5+3P32JD975hJQU52Yp5e13zFptVmZffAY//7iUFb+vxmQyce6fZsZlOLxqMoPJjMnWO+VAJJFBJoY7ga5peCpL8dW0z281OVykDhmOao5uSZ2uBUHXQ8THJL2futp63K0eLBYLrhSnHAgjiSqyT6CHqCYTjrwCTHYHgcZ6TM4U7Fm5UXUAQgh0vw9vTSVC6KgWO/bsnKg7HUlsyMrO7HFvgkQSCaQT6CSq2YItMwdrepYhC6xEd1cuggFqq+tY+tt61q3ZyKFHHkCOgPS8fjIikEgkEUM6gS6gKApKjCSm6xuaue6qu1jyw28APHr/czwy9w4mHZIrnYCkT6FrQYSmg9BRVJPsWo4x0gkkKI0NzW0OAIzjoYfuncu4Xcf0KanejmhuaqGspIJPPvyKMeNHsOvu48iK0qAVSXzRg0Ej31ZrzAMx2R2kDhkhG9ZiSHI4gZ9/hvp6OPTQsAaZRCXYQQ+Cz+vr8/VImqbx1Wff83+X39a2dsDB+3DXgzdKfacEw+fzU1/XwNKf/6CwKJ/C/vldlljW/b42BwCgeT14qytx5PeXEW+MSI7f8gMPwOGHw8iRcO+9UFW18+fEmezcrDBVy3P/NDOi+jGJSH1dA4/c+3TI2jdf/EBLS2ucLJJsTTAYpL6uAZ/XmIw29aDTufqiW5h53BxuveE+GurCO593hOb1hF/D0yp7cGJIcjiBp56Cf/8bCgvh2muhqAhOOw0++QQS9MOWnZPFM688xMVXncuRUw7h8Rfv5YhjDo752MuYI8DvC5fk6O1za/sCdbUNPP/UK1x89nV8/81i7rn1EQL+9vfqk4VfUt+B/MWOMLtSwtas6Zkxy71tSzCoUVNdR11tQ1yuHw+S4zjIboczzjC+li+Hp5+GF16AV1+F4cPhggvgnHMgLy/eloaQm5fNBZeeiRbUOpQn6ItkZKZzzpwZ3Hvbv9rWxowfQWpq+M1CEjs8bg+P3/8sr/z7bQDqaxupq6kPe1zLVoN6OoNiNuMaOBR3WTFCCxoVeBlZnRrcUltTz5pV62ltbmX8bmPIzsns0Sapob6R99/6mHnPLiA1zcVf/noJ43cdjcPZtycNJm+zmNcLb7xhRAlffAEWC5x4Ilx4IRx2GPTy80hd00A3ds+K2dKrpiE11Dex9Jc/ePf1Dxk3YRTHTjuqzyfDE52aqlqmHDgTr9cHwNHHHcaQYQN5/MHn2x6TlZPJgv8+Q04Xu5+FEIgtOTBVRe3Ejby2uo4LZ13N6hXrAEhLT+WVD+bSvyi/S9femoXvfsq1l/697XtVVXnvi3kUDSzs9msmClJFtCPsdjj9dPj8cyM6uOwy+PRTOPJIGDEC7r4bKivjbWWX0TWNoM9rCN6tW0XT2hX46mp6ldhdRmYaBx66L7fffwNnXXCadAAJgKIoZOe2V2gt+uALho8awk13Xs2EPcYxddqRzHvr8W69V4qioFosxlcnd/K//bK8zQEANDU28+xj8/D7/V2+PkBLSytvv/bfkDVd1/n+674vXZ+8TmBrRo+G++6DkhL4z39g4EC4/nojd3DqqbBoUcLmDrZF9/sQfj+txevRfV50vx936UY0T3hiVQiBrmkkajRotfauCCba+Lw+qiprWLNqPVWVNXg9vphdOzM7gxtvbx8mr2kavy75nSknHMGjz97FzXdeTf8BBTF7v2qra8PWqitrCAa7lzuy2awMGTYwbH3QkMQYORpNkiMn0Fnsdpg50/haudLIHTz/PCxYAEOHtucO8rsfckYToesEWpraQ+ut8NXVYHaltpXd6cEA/vpaAq0tWFLTsaZnSEmKBCYY1Pjpx9+4fPYN+Hx+rDYr9z32N/acMBxHhvHeRbOkUlVV9thrAh989TJ/LF3J4KEDycnLwpXijNo1d8QBB++D1WbF72vf+c86/1Sc3Ty/t1gsnD1nBp9+9DVlJRUATDpkH4aNHBwJcxOauOYEFEU5GngIMAFzhRB37+jxcRGQ8/ngzTeN3MFnn4HZDCecYOQOjjgioXIHQtfxVleimM24SzeG/MyR3x97bj6KoqAHg7QWryPQ3NT2c2tWDs6CAZ0Ox3tqpx4MonndqFYrqtkiHdBOqK6q5dRjZockY9Mz0njt3cewNlWTPnIcJqstjhbGFp/PT/HGUv71z2dobm7h3Dkz2WX3caSl96yAoKa6juqqWux2GxmZaWRmda3vIVHZUU4gbk5AURQTsAo4EigBfgRmCiH+2N5zuuME9GAQoWugCxRTD1vSV61qjw5qamDIEDj/fDjvvISJDjS/D93nw1NVRrDVqNQw2eykDh3V9m/veLSgQsaYXWLSqRlobaZ53SrY/NmzZufi7NdfzrbdARVlVRy136lh6x98/hLO5irsuQU4C/rHwbLI4vF4aWlqQQhj9sLO1FXdrW6CQY209NQYWdg7SdTE8N7AGiHEOiGEH5gPnBDJC+jBAO7yEhpXLKVx1TKa1q5A72biCGhvNispgfnzDSdw440wYACcfDJ8+GHccweqxYJqs+MsGEDaiLGkjRgb4gAMOji3VWNzlqsHArhLN7U5AAB/bbXhqD31fSUAACAASURBVGNMouZCOsJqszJ2l1EhayNGD8WibPk39J5/y/ZoqG/k2cf/w5QDZzJ5/+nce9ujO63Xd7qc0gH0kHg6gf5A8Vbfl2xeixi634+/vmar7314qsp73o1os7U3m61aBX/+M3z5JRx9NAwbBnfcAeXlPbS+eyiKislqxex0YXY4MTucYdGPYlKxZYf2RDj6FcZstKAeCG8Gi2WHqB4I4K2tprVkA4Hmpl5ROZWVncEDT93GAYfsg9PlYL8DJ/LQE3/H5msGRcWWvf3B9r2F9Ws38eRDL+Dz+dE0jTdf+YCvP/++088PBAIEOvhsbU0wGKSmqpbijaVUV9bi98tZ4fGMvzvaeoZtZxRFuRC4EGDgwPDs/Y7QfN7wNa8HoeuRS6KNGAH33AO33QZvv23kDv76V7jlFjj+eCN3cOSRkECdvqrJjKNfAdaMTIKtLVhS0lCttphotSgmE9bMbHw17eW3qsVqTLmKAXowQMvGtQTdxlGZv74WR8EA7NmJr85aUNiPfzx8Ez6vD4vFjC3oRdgzsGVHd7ZFrPj+q/Cj3i8+/o6jjzsMq3X7x5Q+r4/yskqef3I+AOfMmUFB//yQsZ9bWLNyPX866xrqaupJSXXxz8f+zsR9d8Nq7f2/v+4Sz099CbB1/VURULbtg4QQTwkhJgohJubmdm2302FLekaUWtJtNpg+HT7+GFavhquvhq+/hmOOMaKD22+HsrB/XtxQzRYsrlQceQWYna6YnccrqoojLx9Hfn9MdgfWjCxSh217XBU9hKa1OYAteKvKEb1EliItPZXcfjlkZGXgyMvHWVCEKUYOvLvU1zVQVVlDbQcdxluz9/67h63tf9BeO3QAAJUVNZw8+TzemP8+b8x/n5Mnn0dVRU3Y42qr67j20r+3Jddbmlu55pK/0dhFqYu+Rjw/OT8CIxRFGaIoihWYAbwTyQsoJjMpQ0ag2mwoJhP23PxOt6T3iOHD4R//MHIHr75qRAs33WT0H0ybBv/9L/SSm040UM0W7Dn9SB06Emf/QbGtaunovVcU+sKZeiJSvLGMi866liP2PpkLZv6ZtavWo29z9NfU2MyGdcWkZ6Yza/apmM0mFEXhqGMP5dCjJu30Ggv+806IhlHAH+D1l98Ne5ym6WxYVxyy1tzUgte78zyhEIKa6jqKN5VRVVmDzxu7Ho1oEzcnIIQIApcCHwLLgVeFEL9H8hqqyYQlJY20oaNJHzkOR7/C2IbNVmt7s9maNXDNNfDttzBlitF3cNttUFoaO3sSCEVVjdLQGB+TKaqKOSU0kRjLfEgyUVdbz1V/uok/lq4EYM2q9Vx8znUhyV53q4fX57/H8YfOYvqU83E4bLz+0fN8+O2r3Hzn1WR1Qpra5QrvVXC6wvsFLFYzu+w2JmQtr18ODsfONyHFG8s4c9pFTD1wJscdMovPFn2Dxx1+3NwbSV7toHjh98M77xi5g0WLjFzBsccauYPJkxMqd9BX0QMBAq3NBN2tWNMzMdnssjw1ClSWV3PkvqeErX/w9csUDTD0eCorqply4MyQnXx6RhpvLHqe3E5qEFWUV3HK5PNoamxue/6Chc/QryBcELK0uJzrLr+N3376nWEjBnPPo7cwdMSgHQrPNdY3ceWFN7Lkf+1DnixWC+99Pg+L1UJ2TmbCd7bLQfOJhNUKp5xifK1dC3PnwrPPGknlAQPa+w6KiuJtaZ9FtViwZWRhy5CaRNHEbDZRNLCQkk3tubCMzHRsWx3/aUEtxAGAcUTTlc1pbl42b3z0HJ9//C0AhxxxQIjO0db0H1DAI8/cSTAQRDWZyO7ExDp/IMDy31eHrAX8ATZtKOG2G+/n/iduZfjIIW2SGr2N3ml1X2HYMLjrLiguNqQpxowxqooGDTIqi95/P6lzB5LeTVZOJvc9/ve20aCpaSnc9/jfychKa3uM3WEPO6I59KhJOBz2Tl/HZDKRl5/L9FknMH3WCeTl5+xwZ5+ZlUFuv5xOOQAAu93G3vvvEbLmdDmwWC1sWl/CFeff0KvnD8jjoERj3Tp45hkjOqioMKKD2bONLxkdSHoZmqZRV9uA1+PF7rCTkZmGZZtKsOrKWp7+10v8umQZ+x+8N7POO7XTN+hYUVlRzQ1X3sGP3/1M/wH5XHfL5bzxyvt8vugbABZ++wqF/RNDNaAjElI2ojvE0gkYvxeBosQpWAoE4N13jdzBRx8ZFSxTpxq5g6OPNjSMJJI+gs/rx93qJiXNFeYkEoXGhiY8bi8r/1jD80++3JYjKOjfj3lvP0FOAkued1s2QlGUNEVRhnWwPiFSxiUaQgg0vx9PZRmtJRsJetzGgJZYY7HASSfBwoVG7uD66+HHH+G44wy5ir/9zThGkkj6ADa7lczsjIR1AGAknPPyc8gvzKN0s9JofmEeDz19R6eqmBKV7UYCiqJMBx4EqgALcI4Q4sfNP/tJCLFHh0+MIrGIBPSAn8bVf4TIMacOG4XFlQD6JIEAvPeeER18+CFCUVCOOQbmzDGa0mR0IJFEHV3XqattwL9Z0jsrOyPhk8LdjQRuAPYUQuwGnAu8pCjKSVteM8I2JgxBtztMj99bmSAdpRYLTJuG/u47+H5eQuCSixBLFhtJ5MGDjaTypk1tD9cDfjzVFbSWboloEl8jRyJJdFRVJSc3i8KifHJysxLeAeyMHW0dTUKIcgAhxP8URTkUeE9RlCL6cnvldjpKBSIhPJ+uBXGXFeNXNDj/HDh7Fo6ff8P++psot91mNKAdcwz67Nk0jRyCvlmd01dbTeqQkaipaTu+gEQSQZoam6mva2Tj+mJGjBpKekZah41ckvixIxfWvHU+YLNDOARD7nlclO2KG2aHEzVExkDBkV8YUYEzXdPQA370YNcVDIWm42+oa1+wmPHsvSfinbdh/XpDvO6XX1BPPpm0wybj+NcTqGWGoqmnsqxXKGZK+gatLW5e+ffbHHfIGVx67v9xzKQZ/O/bn9ASIaqWtLGjnMCugBuwbD3oRVEUCzBDCPFSbExsJ1bVQXoggL+pAT0YwJaRhWKxoKqR6eTVAwHc5cX4mxowWW24BgzGZHN0WgBMC/hpXP5b6KKikDF6q4EwwSDBBQvQH3sUy9dGA03ggP0InnE69nNmo9o7X4Pd19ADATS/D6FrmO0OFLOcYxwtKiuqOeaA00Lm/ubmZfPKB0+Tk9u5bmBJZOhWTkAI8asQYjXwqqIo1ykGDuB+4OIo2ZoQqBYL9uxcnP0KDUmBSDkATcNdUWLs5HUdzeuhee0qRBfO6hU1XDvent0PtrbRbEY9+WTcTz1O4wdv471wNuaVq3FedCnq0KGGmN2GDRH5N/Um9ECA5g2raV67gpb1q2lc9Qd6oAdDhiQ7JOAPhA1+r6ttIBGr0oNBjeqqWspLK6mtqdv5E/oQndl+7oMh+fwthvJnGXBANI2KBULX0fx+/M2NaF5PbI5JdI1AU6hsrdC1Ll3bmAVQSMqQEdhy+pE6ZCT2vH5hQmyqxULasNHYJ+6NftNN6GvXoL/5JuyxB9x5pyFgd8wx8NZbRtXRTqirbWDZryv4fNE3VFZU73R4RyIS9LSiedxt3wstiLeqIqYDbZIJh9PBiFFDQ9aOnHJwl7qBY4HfH+DnxUs59ZjZTN5/OueddiXFG5JH2HGnzWKbZZ7vwJgFnAL8VQgxPwa2hRHJ46BASzPN69vn3Npz+mHvVxDV4SZ6MEjLhjVhevbpoydg2olmekTZtMnoSJ4711AxLSgw9IrOP9+oMtqGutoGbvzzHXzzxf8A44/7P28/zrCRQ8IeK3QdoQURGFPOEkmYzVtbZYy23ApLajqugUNjrmaaLFSWV/Ov+59l2S/LOfCwfTnrgtMSrhu4urKGEw4/i5bm1ra1CbuP5dFn7yYjKz2OlkWOns4Y/hHwAHsBk4CZiqIsiKB9MUcPBGgt3Rgy59ZbU4nQorsjVM1mXEWDQmSLHQVFKKYYl5gNHGg0m23YYCia7rmnoWE0dKjRjfzGGyHRQWV5VZsDAPC4Pdx/5xMhfzRgODlffS2NK3+ncflvtBav63CUZLywpKaHVX/ZcvKkA4gi/Qpyuf7WK5j78gNccvXshHMAAG63J+yz/NvPfxBMkiKKzmzTZgshtmy/K4ATFEU5M4o2xQTR0c0pBscCqs1O+shxCC1oTDhTTfG7CZnNRgfycccZ3cdbooOTT4b8/LbooL4uXByrproubD6r0IK4Sze2fR9obsJbXYkjvzAhJl+pZgtpw0fjLi9F6BqO3HzMDle8zerzOBz2hDsC2hqn00lKqis0EthjHGbLzm+PdbX16JpORmZ6px6fiOz0L3MrB7D1WswrgyKKqmLdRkZYtVijM3ZyGxRFQbVYMNkdm2frJsgudMAAo9lswwZDs2ivveDuu2HYMCbech3HimbMot1JTj/zBDIyQ3sOgh5P2MsGWpsQemKUBCqqitnhImXQUFIHD8eanhnV4yo9GETzefHV1xL0umV5boKSkZnGI8/eRU6ecU8YPnIIdz34VzIyt38U5HF7WPLDr/zpzGs4/YQ/8fxT82mo651jKpNWQE4PBvDWVBForEe1O9pmtUq2oqQEnn0WMXcuSnExTQ4XnxeNxH7ZJew969QwJ6D5vDSuXBayZsvJw5lflBCRQCwRutHP0VqyoW3NnleIPTc8iS+JP1vUToOBIFabdafHVmUlFUw96PSQnoe/3XMt06ZPSciS457mBPokqtmCI6+A1KGjcBUNlg6gI4qK4OabUdavh/few3noIRy39leOuvx8Mk47xZiBsNWxmmI24ygYAJuVV82uFBy5BUnnAGDz0Vh5qMCft7o8YaIiSSgmk4ncvGwK+vfrVN7ipx9/C2t6e/f1D2luatnOMxKX3nmIFSEUVU3KG1SXMZlg6lTMU6ca0cFzzxm5g1NPhX794Nxz4fzzUYcNw5adgy0jEyFE2xzhZCVMb0oIErJIXtJlBgzqH7Y2dPggbLbet5mUd0BJ1ygqMprN1q0zJp/tuy/cey8MHw5HHon6+huoAkxWW1I7AFRTWN7J7HTJTUcfYeCg/hxxzMFt3+cX5nHBpWdis8ew1DtCJG1OQBJBSkuN6ODpp40ehLy8tuiA4cPjbV3c0IMBfLXVBJobMTtTsOfmoyawXr6kazTUNdLU1IzH7SU7N6vXDpWRTiBGGJUhAsVkTsjEUUTQNGMK2lNPGRVGmgaHH25MQzvxRIhlQ1yCIHQdoevy6FESV2RiuIfoWhDN7zMkJvy+Lk0a03WNQGsLLRtW07x2Jb76mr5bKmgyGVIUb75pRAS33w5r1sBppxnHSNdeC6tXx9vKmGLkRczSAUgSFvnJ3AlC1wk01tO4YqkhOrZiKYGmhk7rzYhAkOa1Kwi6W9F8XtwlGwm2NkfZ6gSgsBBuvNEYjfnf/8KkSXD//TBypBEdvPIK+HzxtlIiSXqkE9gJuhaktaw4RG7AXbap08qfgZbwBhJfXXV85hbHA5OpXYqiuBjuuMNIKs+YkbTRgUSSSEgnsDOEIG3ISFIHDydt2GisGVkITet0pV9H/Qeq1d538wI7oqAAbrjBiA4WLoSDDoIHHjCig8MOg/nzZXQQAXQtiB4IIIRUR5XsnKTuE9gZQtfRPB5aNq016rsVBVfRYBSztdNnvCa7E7MrhWCr0USiWCzYc/OT+4xYVWHyZOOrvByef96oLJo5E7Kz4ZxzjGTyyJHdenld00DXUUympPo9C6Gj+3y4y4vR/X6sWTnYMrOTu1RXslNkddAO0AN+Glf9HtL0o5jMpI0Y06UOYz0YMHZmum7Uz8sywXB0HT7+2KgsevttCAbhkEMMZ3DSSdDJJhzN78NTUYrmcWNJz8Ce0y9pboJ6wE/jyt9DupIdBUXYc/JQlORxhpJwZHVQNxFChHV9dmUK2BZUswWzw4nFlRJVB2DMLt7scCLk3IUQ6AE/3tpqvDWVaH5/dIawqCocdRQsWIC+YQP67bcjNm2C00+H/v3h6qth5codvoQeCNC8bhX+hjo0nxdvVQXu8pKkyb9oPm+YLIWvrgYRjN2/3/i8BNB8XmOOtpTJSHikE9gBiqpisjtC1kwOZ0IeMWyZXdywYilN61YQbG2OyM1aBAM0rl6Ou3Qj7rJiGlctQw9Gb0aA5vfR6nfTOO1YWj/5EP2/H8Chh8LDD8Po0UZ08J//gNcbbquuoftDcwpbRnkmA0oHEY9qsYIau/yT7vfRtGY5jSuX0bBiKYGGuqRxwr2VxLubJRCq2ULK4OFYUtJQVBOW1DRSBg1LuOMFoet4ayvx19XA5nPh5vWrI9KP4G9qQGx909d1vNWVUUk66oEAzetXE2huRAQD+JsaaBk5FP3llw3NorvvNiqMzjjDiA6uugpWrGh7fkdHHsZ71XuOPHuCajZjSd9K/ExVcRYOiOq0vK3Rg0FaSza2z20WgtaSjUbToCRhkU5gJ5isNlwDh5I+ahyugUMTUm1UaBr+xm0GvwiB5gvX9+/ya3ewixa6HpX7qtB1dF/oDj/Y0gxCN4TqrrvOKCf9+GM44gh49FEYMwYOPhjmzYOAH3teQcjznUWDOtwh90VUswVX/4GkjRxL6pCRpI8aH9vPq9DRvO6wZb0bR6jJQEN9Iz8vXspjDzzH4u9/ids8AukEOoFqNm8eAJOgxVQdHFtBx+WpXcWantkmDb0Fe26/qByJKaoSdi3jBr7VcYaqtjeblZQg7roLUVoKs2ahDhyE4657SBdmUgaPIH30BMyulKQqx1XNFsx2J5bUNEyWzlexRebiKuaU0BkTJNic6UTB4/Yw79kFnH3ypTzx4POcd9oVPP2vl2htCXei0UY6gT6AajLhLCgyzn83Y8/LD5ll3O3XNltIHzkWW1YO1ows0kaOC7lOV9ADAUN2YzuJa8VkxlU0cKsFBdeAwSjbuYlo6em0zDiZxncW4HnlP4jDDkN5/HFMu+2O9djjML36KqrP3y1bJV1HNZlxFQ4wZjkDqtVG6tAREfkc9jWam1t57sn5IWsvP/8GrS2t23lG9JAlop3EKPHUQFFQVFNC7m7abVTbNGsixZZjoe7uLDWfl+YNa9B9XlSLlZRBwzA5HGHn+LqmGc14wQCqxWII7nVwTT0QoGnN8vbzZ8CakYVNteF7+mlsL7yAZeMGRGYmyllnGaWmY8d2y3ZJ19CDQeMIDwXF3IcFE3tAVUUNk/efHjKYRlEUPvruNfoV5Eb8erJEtIcYCctVNK5cRuOKpbSWboxqhUx3US0WTDY7Jqs14k6qJyqYeiBAy8a1bef9esBP8/rVHZYuqiYTJqsVs9NlzH3ezjWFroU4ADAczfpmL1Pf+YmJ+gDmFO5O6ZgJiMceg3HjDP2il16CDmYhSyJH2/GpxSIdwHZwuhwcf8rkkLWjjj0Up8sec1sSbzubYAih462tQvO23zgCjfVo2bmoKcmRcOw5IuT3B0a/hVHT3r3fYUeVQF5rCjddeSv1dY2gKHxnTuWEKjMLf/qN3IXvGY1oZ50Fl19u/PfCCw3nIJHEmJRUF1dcN4eJ++zG5x9/y6RD9ubgIw4gNS015rbEJRJQFOVeRVFWKIrym6IobyqKkhEPOzqD0AWaJzxZoyXoblLXtOg0c/UERQlLXG/vmKfTmFQc+VuN+FMUVJuDNas2hDws4A/Q6nTBX/5iNJt99pkhaPfEEzB+vBEdvPiijA4kMScrO4PjTp7MXQ/dyLTTppKVHZ/bYLyOgxYB44UQE4BVwPVxsmOnqKbwMYEA5tS0Dh4dP3QtSKClidbi9bjLNqH5fRHrGu4pqtlCysChqJurlRSzhZTBw3qUMFRNZmzZuaSP2oXUoaPIGL0LdoedSYfsE/K4jMx0UlKcxjeKYjSbbek7+Oc/oboazj7bkL6+/HJYtqzbNkkk3cEa52FLcU8MK4oyDThFCHHGzh4br8SwHgzgranCV1uFoqo4CgZgSUlLqOSwv7mRlvXtksyKyUT6VpU8QtcNCQxFiYvdQghEMIgQOoqyJWEY+T1IdWUNt//1Ab7+/AeGjxzMbf+8nmEjB2MymbZnGHz5pXFUtGAB+P2w334wZw7i5JMRNmv7ZLCeRi9JRnVVLQvf/ZTK8ipOmnEs+QV5OF3hpcyS6JPQ4yUVRXkXeEUI8e/t/PxC4EKAgQMH7rlx48ZYmtdG200UEq7iQdeCtGxYGzasJmXQMKzpmW1OzN9Qh2q14iociGqz9VlRseamFrxeHyaTqWshdk2NcTT01FOwciUiPR3flKPxnXwi2siRpAwehsWVKh1BJ6ipquWMEy+ivLQSAFVVeenNx9hltzFxtiw5iUt1kKIoHyuKsqyDrxO2esyNQBCYt73XEUI8JYSYKISYmJsb+dKpzqKoKqrFkqAVDwpKBztdxWQyJCVqqvBWlaP7fQRbmmlaswLRV0dcAqlpKeTmZXf9jDUnx5CiWL4c/ZNP8E/aH9uCN0g/ZSZps84h8PCDiOam6Bjdx1j+++o2BwCg6zqPP/AcLc2xr4OX7JionQsIIY7Y0c8VRTkbOBY4XMQ7HOnlqCYTjvz+BJob2TLtxmR3YLI5EFoQf0NtyOOFrqH5/d1u+urzKApi0iRac9JwX3sV1nc/wP76m7j++jfEvQ/ArFlGZdGECfG2NHHp4C9a/pknJvGqDjoauA44XggR+z7pPojJaiV91Hic/QeSMmgYqUNGGrLViopq6WC6WQLlMxIRRVUwOZyIjAx8Z55O45uv0vzSczB1KsydC7vuCvvuC889B61yd7stY8aPCGl6UhSFP115DimprjhaJemIuOQEFEVZA9iALVvU74UQf9rZ8+LZMdybCXo9NK1Z3iapbM3KwZlfJB3BTtD8PlqLNxBsbcbsdOEaMASTzQ61tUbT2VNPwfLlkJbWHh3sumu8zU4YqitreO/NRVSUV3Hq6cdTWNQPp8sZb7OSkoRODHcF6QS6hxA6IhhE8/tQzYYUg3QAncOQQBCgEC4hLgR8843hDF591ZiPvPfeMGcOnHYauFzbvJYxXU5RVBSzqc8m5iWJh5SN6AJbJmkFmpsIulvRA4knD9FVFEVFtVixuFIx2ezSAXQBQwLB0vEMCUVpbzYrK4MHH4SWFpg9GwoK4OKL4ZdfgM3aSetW0bhiKY2rfyfY2pp4TX2SpERGAtug+X00rV7eNkbS5HSROmh4r50LrAc3yzMIYQjf9dJ/R69BCPj22/bowOtFTJyId9rxeA47GJybj0NUlYxR42VyXhITZCTQSYSu46mqCJkjrLlbCXYwKKM3oAcDuCtKjN3nymU0r18VJromiTCKAgccAC+8AKWl8NBD4HbjuPFmMo+YgvP2uzEtXwm6LiMBSUIgncBWCCEQHdwke+uNU/f7jZGTm9G8Hrw1VfLmEyuysuDyyxG//EzrK/PwH34ItnfeI33GLNJOPxvlueeguXnnryORRBHpBLZCNZmwZW/TkKYoWLadltRL6CiCCbpbozIfWLJ9VIsV+wkn4bnnbho+/gD3DddiEqBedLGhWfSnP8FPP8XbTEmSIp3ANpidKcYsYYcLc0oaacNHJ9xg+c5icYXL0lrTM1HU7ejoSKKGyWYnbego0vY+ANvfboOlvxm5g1NOMRLLe+4JEycauQQZHUhiiHQC26CazVjTM0kdMpyUQUMxO1y9VitGMZtxDRyKsrlpzJaThzUjMyayF0II2SG6DarFgslq2zz712QI1T33nFFZ9MgjhnjdnDlGdDBnDixZEm+TDc0seXzYp5HVQX2cLeqdAJhU1ChHAULX0QN+vDWVoKrYs/OM3oRe6khjihDwww9GNDB/vjHjYI89jCa000+H1NgNHNF1Dd3vx1tVDqqKIzd/h5PeJImNrA7qQxh9DAE0nxc94N/pLk1RlDbhu2g7ADCS6I2rfsdXW42vupLGVb8bDVeSnaMohhTFs88a0cGjj0IgYOQMCgoMZ7B4cZs+VDQRfj9Nq37H31CHv65m8/vY+3tmJOFIJ9DL0H1emtb8QePKZTSsWIa/qQFdD5/VGw+EEEYEsPVNStfDBOyieX094De+YnjD2hL9BD1u49paBN6PjAy45BL49Vf4/nujA3nePNhrLyN/8MQT0BQdRdO29zF0MWbvoyS2SCfQi9CDAVpKNrR3MQud1uL1bXMOEoPwfENMchC6juZppWntShqW/0bLhrVofl/0rysEwdYWGlYspWn1HzQsX0qgqSFy5+iKAvvsA888Y0QHjz1maEBddJERHZx/Pvz4Y+Sjgw6iRllQ0DeRTqA3ITqYdywEaImRuFMUBXtuP9hKE0fZznjOSCO0IM3rV6NvvvEH3S20lmyI+lGUCAZoKV6/1U1Y0Fq6EV2LwnXT042b/88/G7mDmTONUZl7723kDh5/HBobe3wZRVGw5+SF3PQVswVremaPXzsWbInMjKhMHkXuDOkEehOKGtazoKgmFFPivI2q2UL6qHE4+hXiyC8ibcQ4lBiU2G49+W0LwZbm2Jyfb3v0pOvRva6iGDf+uXOhvNy4+YOhVVRYaEQH//tfj2xQLVbSR43D2X8gzqLBpI8YE5P3safowSDe2moaVi6jYflS3GXFMpexExLn7iHZKarZjKv/IMwpRpWIarWROnRkjwa2RxpFVTFZbYYTyMvHZLXG5DhIUdWQCATA5IiBdr2iYnalhCypNnvsFELT0tqbzf73P6OKaP584whp992N46NuRAdGQYEVe3Ye9qwcozIo4SbqhaMH/HjKizfLpgv89bX4G+plufIOkE6gl6FaraQMHEbGmAmkDRuN2Rn/Pgah64b2fnkJreXFaH5fzGvLFZOZlIFDYfPvQrVYSRkwOCqCea0tbkqLy/lk4Zds3FCKyMzHkpaJYjJhSUkjdciI2Av1KYqRNH76aSN38MQTxu/ikkuM6OC884wjpD5+Mwy2hDfaBZojmKPpg8g+AUmP0fw+Glf93ja0Zmb4ugAADq1JREFUBkUhfdR4TNbwiWbRROi6cQas68Yxmdkc8d1rMKjx+aKvufqiW9p2lxf/+VxmzT4Fp91qTHJLFKluIYyGs6eegv/8x5iANmGCUWp6xhlGBVIfI9DaQvPaFSFrjvz+2HPze0UkEy1kn4Akqvjqa9sdAIAQeGuqYm6HoqqYLFZjZoLFEpU/+oa6Bu646cGQ44WnHnmR1hYPqsWaOA4AjOhgixRFeTk8+SSYzXDppe3Rwfff96nowGSzY8/p1/a9OSUNW2ZOUjuAnSGdgKTHdPjn1Uf/5gTQUBd6xh4MagQSvSEuNdWIAJYsMRrOzjwTXnvNkK7YdVejMa2hId5W9hjVbMber4D00RNIH70LKQOHyBkaO0E6AUmPsWbmhNaQb5aL6Is4HHYmH3dYyNrocSNwOu1xsqgb7LmnERWUlRlRgtUKl11mRAfnnAPffderowPVZMZktWKy2nqt+GMskTkBSY8RQkcPBPHX1yCEwJaV06f1gupq6pn/4pt88cm37LLbWC68/Czy+uXE26yesWSJkVSeN88YkTl+vBE5zJoFmb2jP0CyfeSgeYkkwgT8AVqaW3G4HNjtsU2AR5WWFqPE9MknjWMjux2mTzccwv77G3kGSa9DJoYlkghjsVrIzM7oWw4AICWlXYpiyRLjeOjNN2HSJNhlF3j4Yaivj7eVkgginYBE0ovQNQ3N58VXV0OgtSW63bBbpCjKyozuZKcTrrjCyB2cdRZ8/XWvzh1IDKQTkCQcW+Sy9UBAar9sxRaxusaVy2gt2UDz2hWbZRGi/DtKSYHZs42O5J9+gnPPhbfeggMPNHIHDz0EdXXRtUESNaQTkCQUQtcJultoWreChhW/4S7d1K6amqDoWpCgx01r6Sa8NZVRs1cEg7jLNoWs+RvqELGUEt8iRVFebiibpqTAlVca0cGZZ8JXX8nooJchnYAkoRBakOZ1q9B9vs0a9nV4qsoSZmZCRwTdbppW/4Gvtgp3WTFNa1dEzxF0JBuux+Gm63K1S1H8/LMRKbzzDhx0EIwbBw8+CLVy/kBvQDoBSUKh+X1hO8lAUyMk1MyEdvRgEG9laeia3xeVWQaKyYQtOzdkTbXZUExx1vnfbTf417+M3MGzzxqS13/+M/Tvb5SYfvmljA4SGOkEJAmFarFicrhQbe3NVya7o8MhJ4lN5G96iqpiz8nD2X8QZlcqtpw80oaOSpyOWJfLyBd89x388otRZfTuu3DwwTB2LDzwgIwOEhDpBCQJwxalR1tWNo7cfFKHjMTkcOEsHIga793udjBkCgpD16w2TNbodBCrZgu2rBxSBg/DmV+EarFG5To9ZosURVkZPPecIVZ31VVG7uCMM+CLL2R0kCDIZjFJwqB5PTSuXg7CcAYmu4OUwSOiJgYXKXQtiO7346urxmSzY03PSpzdeSLx229GV/JLLxkzDkaNMprQzjoLcnp5x3WCI5vFJAmPrmm4K8vaHAAYTkH3eRPaAYChVWN2OHH1H4Q9p590ANtjwgR45BEjOnj+ecjOhquvNnIHp58On38uo4M4IJ2AJEEQiA56AmSfQB/E6YSzz4ZvvjGigzlz4IMP4NBDYfRouO8+qKmJt5VJg3QCkoRANZmx5+SHrCmqCcs2oxslfYwtUhRlZfDCC8ax0F/+YkQHM2fCZ5/J6CDKSCcgSRjMThcpQ0ZgSU3DmplNWi8Zbi6JAE6nkRv45htYutSYm7xwIRx2mJE7+Oc/obo63lb2SaQTkCQMqtmMNTUd18ChuPoPwmSzJ3w+QBIFtkhRlJXBiy9Cv35wzTVGdDBjBnz6aegkO0mPkE5AknCoJnOfnUUg6QIOR7sUxbJlcPHF8NFHcPjhRnRwzz1QFfsxpn2NuP6lKYryF0VRhKIosj4sSdADATSvB83njb7wmaTvsEWKorTUKDEtKIDrroOiIjjtNPjkExkddJO4OQFFUQYARwKbdvZYSd9AD/hpXreSxlW/b1bCXJ/w4nCSBMPhaJei+OMPuOQSWLQIjjgCRo78//buLcaq8gzj+P8ZZgABjbYllQoywyFKo/EQag8mXnioogh4TJu0vTF6U1toL4zGI3iOje1dE6JtbaB4AEy0Hqu1aYm2CHisooLVYUAFazy1jlV4e/EtHAx7z+zBGb6193p+yYRhsmZ4Qmbm3e/3rfV+cOON7g4GKWcn8EvgIobj+XornYgd9P57G9s/7v3sY5+8/x7be/+bMZU1tRkz0iiKLVtgyZK0Z3Dxxak7OPdceOQRdwcNyFIEJM0BNkfEMw1ce4GkNZLWbPPdAU0rdgTbP9r9F/723t4aV5sNwujRfaMoXngBLrwwLQ+ddBJMnw433ABvvZU7ZWkNWxGQ9Iik52u8zQUuBa5o5OtExOKImBkRM8ePHz/wJ1gptY0YwcgDvrzbxzv23S9DGmtZM2bAzTenvYOlS2HSJLjkktQdnHNOWjpyd/A5e312kKTDgUeBnS8LJwJbgGMi4s3+Ptezg5rbjk8/5eN3ttH79lbU1saYCZNoHzeOthHtuaNZK1u/Ps0suu22NMW0qwvOPz9NPD3wwIE/vwX0Nzso+wA5Sa8BMyNiwOfEXQSaX+zY8dnBKGpv93MAtvf09sLdd8PixWlOUXs7zJ2bhtideCK08G3JHiBnpaG2Nto6Oko/GdRa0OjRfaMo1q+H+fNTMTj5ZJg2Da67Dt7sdzGiJWUvAhHR2UgXYGY2ZHaOoti8GZYtg85OuPTStIdw1lnw0EOV2TvIXgTMzLIZNapvFMVLL8GCBekZhFNOgalT4dpr0y2oLcxFwMwM0sNmN90EPT1w++0wZQpcdhkcfDCceWYaaFfSs66/CBcBM7NdjRrVN4ri5ZfTwTerVsGsWak7uOaaluoOXATMzOqZPj2Noti0Ce64I20gX3556g7mzYMHHmj67sBFwMxsIKNG9Y2ieOWV1B08/jicempaNrr66rTJ3IRcBMzMBmPatNQd9PTAnXemvYQrroDJk1N3cP/9TdUduAiYme2JkSP7RlFs2JAOvnniCTjttPRU8qJFqVCUnIuAmdkXNXUqXH992ju46y449FC48srUHcyZA/fdV9ruwEXAzGyojBwJZ5+dTkDbsCEdfLN6NcyenbqDhQtToSgRFwEzs+EwdWoaRbFpEyxfniacXnVVejr59NPh3nuhBKfruQiYmQ2njo6+URQbN6aDb9asSctEXV2pMGTsDlwEzMz2lilT0iiK7m5YsSKdnbxoUeoOZs/O0h24CJiZ7W0dHX2jKDZuTAffrF2buoPOzrSp3L13jl93ETAzy6mrK42i6O6GlSvh8MPTw2ednel203vuGdbuwEXAzKwMOjrgjDPSKIpXX02jrZ96Kh18M3lymnQ6DFwEzMzKprMzdQOvv55OQzviiPSk8jDw4a5mZmXV0ZFGUcybN2z/hDsBM7MKcxEwM6swFwEzswpzETAzqzAXATOzCnMRMDOrMBcBM7MKcxEwM6swRUTuDA2TtA14PXOMrwBvZ87QKGcdes2SE5x1ODRLTvh81skRMb7WRU1VBMpA0pqImJk7RyOcdeg1S05w1uHQLDmh8axeDjIzqzAXATOzCnMRGLzFuQMMgrMOvWbJCc46HJolJzSY1XsCZmYV5k7AzKzCXATMzCrMRaBBkn4jaauk53NnGYikSZIek/SipH9Kmp87Uy2SRktaLemZIufC3JkGImmEpKck/TF3lv5Iek3Sc5KelrQmd556JO0vabmk9cX367dzZ6pF0iHF/+XOt/clLcidqx5JPyt+pp6XtEzS6LrXek+gMZKOAz4Efh8Rh+XO0x9JE4AJEbFO0r7AWmBeRLyQOdrnSBIwNiI+lNQBrALmR8TfM0erS9LPgZnAfhExO3eeeiS9BsyMiFI/2CTpNuBvEXGLpJHAmIh4N3eu/kgaAWwGvhkRuR9e3Y2kg0g/S1+PiI8k3QncHxG/q3W9O4EGRcRfgXdy52hERLwREeuK9z8AXgQOyptqd5F8WPy1o3gr7asSSROB04BbcmdpBZL2A44DbgWIiP+VvQAUTgA2lrEA7KId2EdSOzAG2FLvQheBFiepEzgK+EfeJLUVyytPA1uBP0VEKXMWfgVcBOzIHaQBATwsaa2kC3KHqWMKsA34bbHEdouksblDNeB7wLLcIeqJiM3AL4Bu4A3gvYh4uN71LgItTNI4YAWwICLez52nlojYHhFHAhOBYySVcqlN0mxga0SszZ2lQcdGxNHALODHxXJm2bQDRwO/joijgP8AF+eN1L9iyWoOcFfuLPVIOgCYC3QBXwPGSvpBvetdBFpUsca+AlgaEStz5xlIsQzwF+CUzFHqORaYU6y13w4cL2lJ3kj1RcSW4s+twN3AMXkT1dQD9OzS/S0nFYUymwWsi4i3cgfpx4nAvyJiW0R8AqwEvlPvYheBFlRsuN4KvBgRN+fOU4+k8ZL2L97fh/TNuz5vqtoi4pKImBgRnaTlgD9HRN1XVzlJGlvcEECxvPJdoHR3tUXEm8AmSYcUHzoBKNXNCzV8nxIvBRW6gW9JGlP8LjiBtC9Yk4tAgyQtA54ADpHUI+m83Jn6cSzwQ9Kr1Z23tJ2aO1QNE4DHJD0LPEnaEyj1rZdN4qvAKknPAKuB+yLiwcyZ6vkJsLT4HjgSuC5znrokjQFOIr2yLq2is1oOrAOeI/2erztCwreImplVmDsBM7MKcxEwM6swFwEzswpzETAzqzAXATOzCnMRMBsikh6U9G7ZJ4ya7cpFwGzo3ER6PsOsabgImA2SpG9IerY4D2FsMbf9sIh4FPggdz6zwWjPHcCs2UTEk5LuAa4B9gGWRETpxjKYNcJFwGzPLCKNuugFfpo5i9ke83KQ2Z75EjAO2Beoe3SfWdm5CJjtmcXA5cBS4MbMWcz2mJeDzAZJ0o+ATyPiD8V5s49LOh5YCBwKjJPUA5wXEQ/lzGo2EE8RNTOrMC8HmZlVmIuAmVmFuQiYmVWYi4CZWYW5CJiZVZiLgJlZhbkImJlV2P8BS8/2Qi8V5LYAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Generate vector to plot decision boundary\n",
    "x1_vec = np.linspace(df_x_pl[\"x1\"].min(),df_x_pl[\"x1\"].max(),2);\n",
    "\n",
    "# Plot raw data\n",
    "sns.scatterplot(x=\"x1\", y=\"x2\", hue=\"y\", data=df_x_pl);\n",
    "\n",
    "# Plot decision boundary\n",
    "plt.plot(x1_vec,(-x1_vec*theta_final[1]-theta_final[0])/theta_final[2], color=\"red\");\n",
    "\n",
    "# Save the theta_final value for later comparisons\n",
    "theta_GA = theta_final.copy()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "7VztviyAOeB7"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "DeTYW9SlOeB8"
   },
   "source": [
    "Write now your considerations. Discuss in particular:\n",
    "- what effects do the learning rate $\\alpha$ and the number of iterations have on the computed $\\theta$\n",
    "- may you still achieve the same value if you decrease the learning rate $\\alpha$ and increase the number of iterations n_iter up to an infinite number of them? Why?\n",
    "- may you still achieve the same value if you increase the learning rate $\\alpha$ substantially and decrease the number of iterations n_iter? Why?\n",
    "\n",
    "Substantiate your answer with experiments and plots of the $l(\\theta)$ and the decision boundary."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "wOZ8520WOeB9"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "UN7JwWH8OeB9"
   },
   "source": [
    "\n",
    "## [15 points] Question 2: Logistic Regression with the Newton's method"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "X_lAFSxwOeB-"
   },
   "source": [
    "### (a) [5 points] Equations for the Hessian of the log likelihood\n",
    "\n",
    "Derive the equation for the Hessian matrix $H$ of the log-likelihood $l(\\theta)$ of the parameters $\\theta$.\n",
    "\n",
    "Recall that: $H_{i,j} = \\frac{\\delta^2 l(\\theta)}{\\delta \\theta_i \\delta \\theta_j}$\n",
    "\n",
    "Also write the parameter update rule for the Newton's method, as a function of the Hessian and gradient of $l(\\theta)$.\n",
    "\n",
    "Question: in order to learn the optimal $\\theta$, do you need to minimize or to maximize $\\nabla_{\\theta} l$?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "c7tXIk65OeB-"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "NUTclFjBOeB_"
   },
   "source": [
    "Your equations and the answer to the question here."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "A2gKz7VDOeB_"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "5c-C9dZeOeCA"
   },
   "source": [
    "### (b) [10 points] Implementation of logistic regression with the Newton's method\n",
    "\n",
    "Code up the equations above to learn the logistic regression parameters. Consider as data the files logistic_x.txt and logistic_y.txt. The first contains the feature values  $x^{(i)}_1$ and $x^{(i)}_2$  for the  𝑖 -th data sample  $x^{(i)}$ . The second contains the ground truth label  $y^{(i)}$  for each corresponding data sample."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "L9IGQc9_OeCA"
   },
   "source": [
    "Define the Hessian function hess_l and the Newton's method function \"newton\":"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "FKOYOByzOeCB"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "8yk_i8EhOeCB"
   },
   "source": [
    "Your code here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "gxH5xTi0OeCC"
   },
   "outputs": [],
   "source": [
    "def hess_l(theta, x, y):\n",
    "    pass # return the Hessian matrix hess\n",
    "    # return hess\n",
    "\n",
    "def newton(theta0, x, y, G, H, eps):\n",
    "    pass # return the optimized theta parameters,\n",
    "        # as well as two lists containing the log likelihood's and values of theta at all iterations\n",
    "    # return theta, theta_history, log_l_history"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "r6z0jueTOeCG"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check your hess_l implementation: hess_l applied to the theta_test (defined below) should provide a value for hess_l_test close to the target_value (defined below); in other words the error_test should be 0, up to machine error precision."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "target_value = np.array([[-0.14357024, -0.43836134,  0.18767787], \\\n",
    "                         [-0.43836134, -1.72295801,  0.61817001], \\\n",
    "                         [ 0.18767787,  0.61817001, -0.51247901]])\n",
    "theta_test=np.array([-2,1,2])\n",
    "\n",
    "hess_l_test  = hess_l(theta_test,x,y)\n",
    "error_test=np.sum(np.abs(hess_l_test-target_value),axis=(0,1))\n",
    "\n",
    "print(\"{:f}\".format(error_test))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "48hVqShUOeCG"
   },
   "source": [
    "Now run Newton's method to perform logistic regression:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "id": "dhw9YOdVOeCH",
    "outputId": "f8bddc10-e9d3-4792-f8d4-73f1ba1d1e68"
   },
   "outputs": [],
   "source": [
    "# Initialize theta0\n",
    "theta0 = np.zeros(x.shape[1])\n",
    "\n",
    "# Run Newton's method\n",
    "theta_final, theta_history, log_l_history = newton(theta0,x,y,grad_l,hess_l,1e-6)\n",
    "print(theta_final)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "swC4RWi0OeCJ"
   },
   "source": [
    "Let's plot the log likelihood over iterations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 279
    },
    "id": "5TDSytMMOeCK",
    "outputId": "06d5feca-7b74-4216-a5db-deb251c7f142"
   },
   "outputs": [],
   "source": [
    "fig,ax = plt.subplots(num=2)\n",
    "\n",
    "ax.set_ylabel('l(Theta)')\n",
    "ax.set_xlabel('Iterations')\n",
    "_=ax.plot(range(len(log_l_history)),log_l_history,'b.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "xnGtGzYDOeCN"
   },
   "source": [
    "Plot the data and our decision boundary:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 195
    },
    "id": "dhDCM-n4OeCO",
    "outputId": "383e7da5-82e7-4b61-df54-d4032a28b0eb"
   },
   "outputs": [],
   "source": [
    "df_x_pl=df_x.copy()\n",
    "df_y_pl=df_y.copy()\n",
    "df_x_pl.insert(0, \"y\", df_y)\n",
    "df_x_pl[\"y\"] = pd.to_numeric(df_x_pl[\"y\"],downcast='signed')\n",
    "df_x_pl.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 279
    },
    "id": "g_5r0nW5OeCR",
    "outputId": "8e8e832f-a6a4-426b-ad28-77607ba8adc3",
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Generate vector to plot decision boundary\n",
    "x1_vec = np.linspace(df_x_pl[\"x1\"].min(),df_x_pl[\"x1\"].max(),2);\n",
    "\n",
    "# Plot raw data\n",
    "sns.scatterplot(x=\"x1\", y=\"x2\", hue=\"y\", data=df_x_pl);\n",
    "\n",
    "# Plot decision boundary\n",
    "plt.plot(x1_vec,(-x1_vec*theta_final[1]-theta_final[0])/theta_final[2], color=\"red\");"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "27QoXQikOeCT"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "4rPY_EKzOeCT"
   },
   "source": [
    "Write now your considerations. Discuss in particular:\n",
    "- the different convergence speed of the Newton's method, compared to Gradient Ascent\n",
    "- the incurred cost for the different convergence speed"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "po-FgiDPOeCT"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "lqj8HMJMOeCU"
   },
   "source": [
    "\n",
    "## [7 points] Question 3: Logistic Regression with non linear boundaries"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "C1phEkjHOeCU"
   },
   "source": [
    "### (a) Polynomial features for logistic regression\n",
    "\n",
    "Define new features, e.g. of 2nd and 3rd degrees, and learn a logistic regression classifier by using the new features, by using the Newton's optimization algorithm (or the gradient ascent one, if you like)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "dRbt5SbZPcn6"
   },
   "source": [
    "In particular, we would consider a polynomial boundary with equation:\n",
    "\n",
    "$f(x_1, x_2) = c_0 + c_1 x_1 + c_2 x_2 + c_3 x_1^2 + c_4 x_2^2 + c_5 x_1 x_2 + c_6 x_1^3 + c_7 x_2^3 + c_8 x_1^2 x_2 + c_9 x_1 x_2^2$\n",
    "\n",
    "We would therefore compute 7 new features: 3 new ones for the quadratic terms and 4 new ones for the cubic terms.\n",
    "\n",
    "Create new arrays by stacking x (from the previous questions) and the new 7 features (in the order x1x1, x2x2, x1x2, x1x1x1, x2x2x2, x1x1x2, x1x2x2). In particular create x_new_quad by additionally stacking with x the quadratic features, and x_new_cubic by additionally stacking with x the quadratic and the cubic features."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "BQTbat6UOeCV",
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "# First extract features x1 and x2 from x and reshape them to x1 vector arrays\n",
    "x1 = x[:,1]\n",
    "x2 = x[:,2]\n",
    "x1 = x1.reshape(x1.shape[0], 1)\n",
    "x2 = x2.reshape(x2.shape[0], 1)\n",
    "print(x[:5,:]) # For visualization of the first 5 values\n",
    "print(x1[:5,:]) # For visualization of the first 5 values\n",
    "print(x2[:5,:]) # For visualization of the first 5 values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "rL2ZN00OOeCX"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "rsyCm-uNOeCY"
   },
   "source": [
    "Your code here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ROZQgI2COeCY"
   },
   "outputs": [],
   "source": [
    "# Define features: x1x1, x2x2, x1x2, x1x1x1, x2x2x2, x1x1x2, x1x2x2\n",
    "\n",
    "# Stack the features together together with x, to define\n",
    "# x_new_quad [x, x1x1, x2x2, x1x2]\n",
    "# and x_new_cubic [x, x1x1, x2x2, x1x2, x1x1x1, x2x2x2, x1x1x2, x1x2x2]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "_KvgwVckOeCe"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "if0-ozefOeCe"
   },
   "source": [
    "Now use the Newton's optimization algorithm to learn theta by maximizing the log-likelihood, both for the case of x_new_quad and x_new_cubic.\n",
    "\n",
    "Note: you may alternatively use gradient ascent, as in Question 1, if you like."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "rVe936XNOeCe"
   },
   "outputs": [],
   "source": [
    "# Initialize theta0, in case of quadratic features\n",
    "theta0_quad = np.zeros(x_new_quad.shape[1])\n",
    "\n",
    "# Run Newton's method, in case of quadratic features\n",
    "theta_final_quad, theta_history_quad, log_l_history_quad = newton(theta0_quad,x_new_quad,y,grad_l,hess_l,1e-6)\n",
    "\n",
    "# Initialize theta0, in case of quadratic and cubic features\n",
    "theta0_cubic = np.zeros(x_new_cubic.shape[1])\n",
    "\n",
    "# Run Newton's method, in case of quadratic and cubic features\n",
    "theta_final_cubic, theta_history_cubic, log_l_history_cubic = newton(theta0_cubic,x_new_cubic,y,grad_l,hess_l,1e-6)\n",
    "\n",
    "# check and compare with previous results\n",
    "print(theta_final_quad)\n",
    "print(theta_final_cubic)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 279
    },
    "id": "0fdHd2L8OeCh",
    "outputId": "90db5074-51ff-458e-be72-e5bd3ae4a935"
   },
   "outputs": [],
   "source": [
    "# Plot the log likelihood values in the optimization iterations, in one of the two cases.\n",
    "fig,ax = plt.subplots(num=2)\n",
    "\n",
    "ax.set_ylabel('l(Theta)')\n",
    "ax.set_xlabel('Iterations')\n",
    "_=ax.plot(range(len(log_l_history_cubic)),log_l_history_cubic,'b.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "oyHrTkyVOeCj"
   },
   "source": [
    "### (b) Plot the computed non-linear boundary and discuss the questions\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "XLqrjKy9OeCj"
   },
   "source": [
    "First, define a boundary_function to compute the boundary equation for the input feature vectors $x_1$ and $x_2$, according to estimated parameters theta, both in the case of quadratic (theta_final_quad) and of quadratic and cubic features (theta_final_cubic). Refer for the equation to the introductory part of Question 3."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "aRfx4RsEOeCj"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Your code here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Q9z3OOOdOeCk"
   },
   "outputs": [],
   "source": [
    "def boundary_function(x1_vec, x2_vec, theta_final):\n",
    "    \n",
    "    x1_vec, x2_vec = np.meshgrid(x1_vec,x2_vec)\n",
    "    \n",
    "    if len(theta_final) == 6:\n",
    "        # boundary function value for features up to quadratic\n",
    "        c_0, c_1, c_2, c_3, c_4, c_5 = theta_final\n",
    "        # f =\n",
    "    elif len(theta_final) == 10:\n",
    "        # boundary function value for features up to cubic\n",
    "        c_0, c_1, c_2, c_3, c_4, c_5, c_6, c_7, c_8, c_9 = theta_final\n",
    "        # f = \n",
    "    else:\n",
    "        raise(\"Number of Parameters is not correct\")\n",
    "        \n",
    "    return x1_vec, x2_vec, f"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "APohoz_HOeCq"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now plot the decision boundaries corresponding to the theta_final_quad and theta_final_cubic solutions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 296
    },
    "id": "y8dN6C_YOeCq",
    "outputId": "7537487b-2361-4de9-8024-51b67ba30436"
   },
   "outputs": [],
   "source": [
    "x1_vec = np.linspace(df_x_pl[\"x1\"].min()-1,df_x_pl[\"x1\"].max()+1,200);\n",
    "x2_vec = np.linspace(df_x_pl[\"x2\"].min()-1,df_x_pl[\"x2\"].max()+1,200);\n",
    "\n",
    "x1_vec, x2_vec, f = boundary_function(x1_vec, x2_vec, theta_final_quad)\n",
    "\n",
    "sns.scatterplot(x=\"x1\", y=\"x2\", hue=\"y\", data=df_x_pl);\n",
    "\n",
    "plt.contour(x1_vec, x2_vec, f, colors=\"red\", levels=[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x1_vec = np.linspace(df_x_pl[\"x1\"].min()-1,df_x_pl[\"x1\"].max()+1,200);\n",
    "x2_vec = np.linspace(df_x_pl[\"x2\"].min()-1,df_x_pl[\"x2\"].max()+1,200);\n",
    "\n",
    "x1_vec, x2_vec, f = boundary_function(x1_vec, x2_vec, theta_final_cubic)\n",
    "\n",
    "sns.scatterplot(x=\"x1\", y=\"x2\", hue=\"y\", data=df_x_pl);\n",
    "\n",
    "plt.contour(x1_vec, x2_vec, f, colors=\"red\", levels=[0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "x2q06ghtctFD"
   },
   "source": [
    "################# Do not write above this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "BRKJBKIoOeCt"
   },
   "source": [
    "Write now your considerations. Discuss in particular:\n",
    "- What happens if you further increase the degree of the polynomial. How would the boundary change? Would you incur underfitting or overfitting?\n",
    "- Look at the boundary of the quadratic and cubic polynomial features. Do they meet your expectations? Why? Consider in particular the classifier decision boundary in areas where there are fewer training data, i.e. where the classifier is supposed to generalize. Hint: Try changing the minimum and maximum limits in vectors x1_vec and x2_vec before plotting the boundaries.\n",
    "- Look at the values of the original features, the 2nd and 3rd degree ones. Do you expect that normalizing the input features (either by setting their range to [-1,1] or by subtracting their mean and dividing by their standard deviation) would improve the classifier? Why yes or why not?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "rqCIJlppcvpJ"
   },
   "source": [
    "################# Do not write below this line #################"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "vBXW0UPaOeCt"
   },
   "source": [
    "\n",
    "## [10 points, extra, not compulsory] Question 4: Gaussian Discriminant Analysis\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "7XCqvVbVOeCt"
   },
   "source": [
    "### (a) Review and implement classification with Gradient Discriminant Analysis (GDA)\n",
    "\n",
    "Recall the assumptions for GDA\n",
    "\n",
    "$\\begin{aligned} y & \\sim \\operatorname{Bernoulli}(\\phi) \\\\ x \\mid y=0 & \\sim \\mathcal{N}\\left(\\mu_{0}, \\Sigma\\right) \\\\ x \\mid y=1 & \\sim \\mathcal{N}\\left(\\mu_{1}, \\Sigma\\right) \\end{aligned}$\n",
    "\n",
    "Recall the probability distributions:\n",
    "\n",
    "$\\begin{aligned} p(y) &=\\phi^{y}(1-\\phi)^{1-y} \\\\ p(x \\mid y=0) &=\\frac{1}{(2 \\pi)^{d / 2}|\\Sigma|^{1 / 2}} \\exp \\left(-\\frac{1}{2}\\left(x-\\mu_{0}\\right)^{T} \\Sigma^{-1}\\left(x-\\mu_{0}\\right)\\right) \\\\ p(x \\mid y=1) &=\\frac{1}{(2 \\pi)^{d / 2}|\\Sigma|^{1 / 2}} \\exp \\left(-\\frac{1}{2}\\left(x-\\mu_{1}\\right)^{T} \\Sigma^{-1}\\left(x-\\mu_{1}\\right)\\right) \\end{aligned}$\n",
    "\n",
    "Overall, the parameters of the model are $\\phi, \\Sigma, \\mu_{0}$ and $\\mu_{1}$ and the log-likelihood is given by:\n",
    "\n",
    "$\\begin{aligned} \\ell\\left(\\phi, \\mu_{0}, \\mu_{1}, \\Sigma\\right) &=\\log \\prod_{i=1}^{n} p\\left(x^{(i)}, y^{(i)} ; \\phi, \\mu_{0}, \\mu_{1}, \\Sigma\\right) \\\\ &=\\log \\prod_{i=1}^{n} p\\left(x^{(i)} \\mid y^{(i)} ; \\mu_{0}, \\mu_{1}, \\Sigma\\right) p\\left(y^{(i)} ; \\phi\\right) \\end{aligned}$\n",
    "\n",
    "Parameters may be estimated by maximum likelihood estimate as follows:\n",
    "\n",
    "$\\begin{aligned} \\phi &=\\frac{1}{n} \\sum_{i=1}^{n} 1\\left\\{y^{(i)}=1\\right\\} \\\\ \\mu_{0} &=\\frac{\\sum_{i=1}^{n} 1\\left\\{y^{(i)}=0\\right\\} x^{(i)}}{\\sum_{i=1}^{n} 1\\left\\{y^{(i)}=0\\right\\}} \\\\ \\mu_{1} &=\\frac{\\sum_{i=1}^{n} 1\\left\\{y^{(i)}=1\\right\\} x^{(i)}}{\\sum_{i=1}^{n} 1\\left\\{y^{(i)}=1\\right\\}} \\\\ \\Sigma &=\\frac{1}{n} \\sum_{i=1}^{n}\\left(x^{(i)}-\\mu_{y^{(i)}}\\right)\\left(x^{(i)}-\\mu_{y^{(i)}}\\right)^{T} \\end{aligned}$\n",
    "\n",
    "Consider the data variables as from the previous questions, x and y.\n",
    "For this question, we would select features $x^{(i)}_1$ and $x^{(i)}_2$ into the new varible x12, dropping the $x_0=1$ convention."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# First extract the sole features x1 and x2 from x into an x12 array and reshape it to x2 vector arrays\n",
    "x12 = x[:,1:]\n",
    "print(x[:5,:]) # For visualization of the first 5 values\n",
    "print(x12[:5,:]) # For visualization of the first 5 values\n",
    "print(y[:5]) # For visualization of the first 5 values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now code up the equations above to learn the GDA parameters from the training data."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "################# Do not write above this line #################\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Your code here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def compute_phi(y):\n",
    "  # your code here\n",
    "  pass\n",
    "\n",
    "\n",
    "def compute_mu0(x, y):\n",
    "  # your code here\n",
    "  pass\n",
    "\n",
    "\n",
    "def compute_mu1(x, y):\n",
    "  # your code here\n",
    "  pass\n",
    "\n",
    "\n",
    "def compute_sigma(x, y, mu0, mu1):\n",
    "  # your code here\n",
    "  pass\n",
    "\n",
    "\n",
    "# computing p(x|y) for the Bayes rule\n",
    "def p_x_given_y(x,mu,sigma):\n",
    "  # your code here\n",
    "  pass\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "7X0KeBHGEyMA"
   },
   "source": [
    "\n",
    "################# Do not write below this line #################\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Support functions\n",
    "\n",
    "# Function p(y) for applying the Bayes rule\n",
    "def p_y(y,phi):\n",
    "    if y==1: return phi\n",
    "    else: return 1-phi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 105
    },
    "id": "VJS9V7u-hr3C",
    "outputId": "736f893a-35af-4344-bba5-752903be8abe"
   },
   "outputs": [],
   "source": [
    "# Now estimate the GDA parameters\n",
    "phi = compute_phi(y)\n",
    "mu0 = compute_mu0(x12,y)\n",
    "mu1 = compute_mu1(x12,y)\n",
    "sigma = compute_sigma(x12, y, mu0, mu1)\n",
    "\n",
    "phi,mu0,mu1,sigma"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Q2MEcgHI0zZG"
   },
   "source": [
    "Now that we know both the distributions of $p(y)$ and $p(x|y)$, we may estimate the posterior probability for an input $x$ via Bayes Rule:\n",
    "\n",
    "\\begin{equation}\n",
    "p(y \\mid x)=\\frac{p(x \\mid y) p(y)}{p(x)}\n",
    "\\end{equation}\n",
    "where $p(x)$ is the same for both classes and may be disregarded.\n",
    "\n",
    "This is used to classify each data point, by comparing $p(y=1|x) \\propto p(x \\mid y=1) p(y=1)$ and $p(y=0|x) \\propto p(x \\mid y=0) p(y=0)$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 52
    },
    "id": "QXOCMphE-s3W",
    "outputId": "fb86b8d4-0a70-410e-bb29-34f5ddc4e4d6"
   },
   "outputs": [],
   "source": [
    "selected_example=1\n",
    "print('Selected example =', x12[selected_example,:])\n",
    "\n",
    "# compute p(y=0|x) ~ p(x|y=0)*p(y=0)  &  p(y=1|x) ~ p(x|y=1)*p(y=1)\n",
    "\n",
    "# y=0\n",
    "print('p(y=0|x) ~', p_x_given_y(x12[selected_example,:],mu0,sigma)*p_y(0,phi))\n",
    "\n",
    "# y=1\n",
    "print('p(y=1|x) ~', p_x_given_y(x12[selected_example,:],mu1,sigma)*p_y(1,phi))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "j-LisANTOeCu"
   },
   "source": [
    "### (b) Plot the estimated likelihood functions, the decision boundary and write your remarks\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def boundary_gda(x1_vec, x2_vec, mu0, mu1, sigma, phi):\n",
    "    \n",
    "    x1_vec, x2_vec = np.meshgrid(x1_vec,x2_vec)\n",
    "    \n",
    "    f=np.zeros(x1_vec.shape)\n",
    "    \n",
    "    for i in range(f.shape[0]):\n",
    "        for j in range(f.shape[1]):\n",
    "            x12_ij = np.array( (x1_vec[i,j],x2_vec[i,j]) )\n",
    "            f[i,j] = p_x_given_y(x12_ij,mu1,sigma)*p_y(1,phi) - p_x_given_y(x12_ij,mu0,sigma)*p_y(0,phi)\n",
    "            \n",
    "    return x1_vec, x2_vec, f\n",
    "\n",
    "\n",
    "x1_vec = np.linspace(df_x_pl[\"x1\"].min()-1,df_x_pl[\"x1\"].max()+1,200);\n",
    "x2_vec = np.linspace(df_x_pl[\"x2\"].min()-1,df_x_pl[\"x2\"].max()+1,200);\n",
    "\n",
    "x1_vec, x2_vec, f = boundary_gda(x1_vec, x2_vec, mu0, mu1, sigma, phi)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import cm\n",
    "from scipy.stats import multivariate_normal\n",
    "\n",
    "# Define Gaussian pdfs\n",
    "rv0 = multivariate_normal(mu0, sigma)\n",
    "rv1 = multivariate_normal(mu1, sigma)\n",
    "\n",
    "pairx12 = np.dstack((x1_vec, x2_vec))\n",
    "\n",
    "# plot pdf contours\n",
    "plt.contourf(x1_vec, x2_vec, rv0.pdf(pairx12),alpha=0.5,cmap=cm.Reds)\n",
    "plt.contourf(x1_vec, x2_vec, rv1.pdf(pairx12),alpha=0.35,cmap=cm.Blues)\n",
    "\n",
    "# Add the GDA classification to the plot\n",
    "sns.scatterplot(x=\"x1\", y=\"x2\", hue=\"y\", data=df_x_pl);\n",
    "plt.contour(x1_vec, x2_vec, f, colors=\"red\", levels=[0])\n",
    "\n",
    "plt.ylim(df_x_pl[\"x2\"].min()-1,df_x_pl[\"x2\"].max()+1)\n",
    "plt.xlim(df_x_pl[\"x1\"].min()-1,df_x_pl[\"x1\"].max()+1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# For comparison with the Logistic Regression boundary\n",
    "\n",
    "# Generate vector to plot decision boundary\n",
    "x1vec = np.linspace(df_x_pl[\"x1\"].min()-1,df_x_pl[\"x1\"].max()+1,2)\n",
    "\n",
    "# Plot raw data\n",
    "sns.scatterplot(x=\"x1\", y=\"x2\", hue=\"y\", data=df_x_pl)\n",
    "\n",
    "# Plot decision boundary\n",
    "log, = plt.plot(x1vec,(-x1vec*theta_GA[1]-theta_GA[0])/theta_GA[2], color=\"red\")\n",
    "gda = plt.contour(x1_vec, x2_vec, f, colors=\"green\", levels=[0])\n",
    "\n",
    "plt.legend([log, gda.collections[0]],['logistic regression','GDA'])\n",
    "\n",
    "plt.ylim(df_x_pl[\"x2\"].min()-1,df_x_pl[\"x2\"].max()+1)\n",
    "plt.xlim(df_x_pl[\"x1\"].min()-1,df_x_pl[\"x1\"].max()+1)\n",
    "\n",
    "# plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "xiSJyf3lOeCu"
   },
   "source": [
    "Write now your considerations. Discuss in particular:\n",
    "- Gaussian Discriminant Analysis makes stronger modelling assumptions than logistic regression. When may this be helpful and where may this be harmful?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "p6KSzi2BOeCu"
   },
   "source": [
    "Credits for material: Andrew Ng, C. Combier"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [
    "7XCqvVbVOeCt",
    "j-LisANTOeCu",
    "Z2o9jg7EOeCv"
   ],
   "name": "FDS_Exercise_2_own.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
